const tokenAmount = document.getElementById('tokenAmount')
let tokens = localStorage.getItem('tokens') ? localStorage.getItem('tokens') : 0
tokenAmount.innerHTML = tokens
localStorage.setItem('tokens', tokens)
const lootboxesAmount = document.getElementById('lootboxesAmount')
let lootboxes = localStorage.getItem('lootboxes') ? localStorage.getItem('lootboxes') : 3
localStorage.setItem('lootboxes', lootboxes)
lootboxesAmount.innerHTML = lootboxes
const degugButton = document.getElementById('debugButton')
const sendToStore1 = document.getElementById('sendToStore1')
const lootBoxIcon = document.getElementById('summonLootbox')
const popupOverlay = document.getElementById('popupOverlay');
const noLootboxPopup = document.getElementById('noLootboxPopup');
const goToShopButton = document.getElementById('goToShopButton');
const closePopupButton = document.getElementById('closePopupButton');
const shopButton = document.getElementById('shopButton');
const debugBox = document.getElementById('debugBox');
const clipboardButton = document.getElementById('clipboardButton');
const clipboardOverlay = document.getElementById('clipboardOverlay');
const closeClipboard = document.getElementById('closeClipboard');
const prevPage = document.getElementById('prevPage');
const nextPage = document.getElementById('nextPage');
const pageNumber = document.getElementById('pageNumber');
const Encyclopedia = document.getElementById('Encyclopedia');
const Settings = document.getElementById('Settings');
const techTree = document.getElementById('TechTree');

let chessboard;
let currentPage = 1;
let loadedSettings = loadSettings();

function loadPage(pageElement, pageNum) {
    pageElement.innerHTML = autoGeneratedRulebook[pageNum];
}

function setPlayerIndicator(color, elementIdentifiers) {
    const whitePlayer = document.getElementById(elementIdentifiers.white);
    const blackPlayer = document.getElementById(elementIdentifiers.black);

    if (color.toLowerCase() === 'white') {
        whitePlayer.classList.add('active');
        blackPlayer.classList.remove('active');
    } else if (color.toLowerCase() === 'black') {
        blackPlayer.classList.add('active');
        whitePlayer.classList.remove('active');
    } else {
        console.error('Invalid color. Use "white" or "black".');
    }
}

function switchActivePlayer() {
    if (chessboard) {
        chessboard.switchActivePlayer();

    }
}



function loadSettings() {
    let currentSettings = {};
    let settings = JSON.parse(localStorage.getItem('chessSettings')) || {};
    if (!localStorage.getItem('chessSettings')) {
        localStorage.setItem('chessSettings', JSON.stringify(defaultSettings));
    }
    currentSettings = { ...defaultSettings, ...settings };
    return currentSettings;
}

function showPage(pageNum) {
    document.querySelectorAll('.clipboard-page').forEach(page => page.style.display = 'none');
    const pageElement = document.getElementById(`page`);
    pageElement.style.display = 'block';
    loadPage(pageElement, pageNum);
    pageNumber.textContent = `Page ${pageNum} / ${totalPages}`;
}

clipboardButton.addEventListener('click', () => {
    clipboardOverlay.style.display = 'block';
    showPage(currentPage);
});

closeClipboard.addEventListener('click', () => {
    clipboardOverlay.style.display = 'none';
});

clipboardOverlay.addEventListener('click', (event) => {
    if (event.target === clipboardOverlay) {
        clipboardOverlay.style.display = 'none';
    }
});

prevPage.addEventListener('click', () => {
    if (currentPage > 1) {
        currentPage--;
        showPage(currentPage);
    }
});

nextPage.addEventListener('click', () => {
    if (currentPage < totalPages) {
        currentPage++;
        showPage(currentPage);
    }
});



if (!DEBUG_MODE) {
    debugBox.style.display = 'none';
}

function showPopup() {
    popupOverlay.style.display = 'block';
    noLootboxPopup.style.display = 'block';
}

function hidePopup() {
    popupOverlay.style.display = 'none';
    noLootboxPopup.style.display = 'none';
}

function createChessboard(givenGameState) {
    try {
        chessboard.unsubscribe();
    } catch (e) {
    }
    chessboard = new Chessboard(undefined, givenGameState, undefined, { "lootBoxAnimation": true }, loadedSettings);
}


window.onload = () => {
    console.log(setupData)

    gameState = localStorage.getItem('gameState') ? JSON.parse(localStorage.getItem('gameState')) : undefined;
    if (!DEBUG_MODE) {
        localStorage.removeItem('gameState')
    }

    createChessboard(gameState);
    gameState = chessboard.getGameState();
    allEvents.emit('chessboardInit', gameState);
    sendToStore1.addEventListener('click', () => {
        localStorage.setItem('tokens', tokens)
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()))
        window.location.href = './store'
    })

    if (loadedSettings.allowLootboxSummoning == "2") {
        lootBoxIcon.style.display = 'none';
    } else {
        lootBoxIcon.addEventListener('click', () => {
            let free_box = percentageRandomiser(FREE_LOOTBOX_CHANCE)
            lootboxes = localStorage.getItem('lootboxes') ? localStorage.getItem('lootboxes') : 0
            if (lootboxes <= 0 && !free_box) {
                if (AUTO_BUY_BOXES && tokens >= AUTO_BUY_BOXES) {
                    lootboxes = 1
                    tokens -= AUTO_BUY_BOXES
                    localStorage.setItem('tokens', tokens)
                    tokenAmount.innerHTML = tokens
                } else {
                    console.warn('No lootboxes left');
                    showPopup();
                    return;
                }
            }
            let success = chessboard?.generateLootBox(chessboard?.getGameState(), 'lootbox', 100);
            if (success) {
                if (!free_box) {
                    lootboxes--;
                }
                lootboxesAmount.innerHTML = lootboxes;
                render();
                localStorage.setItem('lootboxes', lootboxes);
            }
        });
    }


    closePopupButton.addEventListener('click', hidePopup);

    popupOverlay.addEventListener('click', (event) => {
        if (event.target === popupOverlay) {
            hidePopup();
        }
    });

    goToShopButton.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()));
        window.location.href = './shop';
    });

    shopButton.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()));
        window.location.href = './shop';
    });

    clipboardButton.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()))
        clipboardOverlay.style.display = 'block';
        showPage(currentPage);
    });

    Encyclopedia.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()))
        window.location.href = './encyclopedia';
    });

    Settings.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()))
        window.location.href = './settings';
    });
    techTree.addEventListener('click', () => {
        localStorage.setItem('gameState', JSON.stringify(chessboard?.getGameState()))
        window.location.href = './techTree';
    });

    // degugButton.addEventListener('click', () => {
    //     console.warn('Debugging button clicked')
    // })
};

let progress = {
    white: { slainTroops: { king: 0 } },
    black: { slainTroops: { king: 0 } }
};

function updateWinConditionBox() {
    const box = document.getElementById('winConditionBox');
    box.innerHTML = '<h2>Win Conditions</h2>';

    ['white', 'black'].forEach(player => {
        const playerSection = document.createElement('div');
        playerSection.className = 'player-section';
        playerSection.innerHTML = `<div class="player-title">${player.charAt(0).toUpperCase() + player.slice(1)} Player</div>`;

        for (const [condition, piecesToKill] of Object.entries(WIN_CONDITIONS)) {
            const conditionDiv = document.createElement('div');
            conditionDiv.className = 'condition';
            conditionDiv.innerHTML = `<div class="condition-title">${condition}</div>`;

            for (const [piece, count] of Object.entries(piecesToKill)) {
                const pieceDiv = document.createElement('div');
                pieceDiv.className = 'piece-progress';
                const currentProgress = progress[player][condition]?.[piece] || 0;
                pieceDiv.innerHTML = `
                    <div class="square">${pieces[piece].display[player]}</div>
                    <span>${piece}:</span>
                    <span class="progress-text">${currentProgress}/${count}</span>
                `;

                conditionDiv.appendChild(pieceDiv);
            }

            playerSection.appendChild(conditionDiv);
        }

        box.appendChild(playerSection);
    });
}

function updateProgress(player, condition, piece, newValue) {
    if (!progress[player][condition]) {
        progress[player][condition] = {};
    }
    progress[player][condition][piece] = newValue;
    updateWinConditionBox();
}

// Initial render
updateWinConditionBox();

const craftingOverlay = document.getElementById('craftingOverlay');
const closeCrafting = document.getElementById('closeCrafting');
const craftingList = document.getElementById('craftingList');
const craftingHeader = document.querySelector('.crafting-header');

function showCraftingOverlay(player) {
    craftingHeader.textContent = `${player} Player Crafting`;
    craftingOverlay.style.display = 'block';
    populateCraftingList(player);
}

closeCrafting.addEventListener('click', () => {
    craftingOverlay.style.display = 'none';
});

function populateCraftingList(player) {
    // This is a placeholder function. In a real implementation,
    // you would fetch the available crafting options for the player
    // and populate the list dynamically.


    craftingList.innerHTML = '';

    craftableItems.forEach(item => {
        const itemElement = document.createElement('div');
        itemElement.className = 'crafting-item';
        itemElement.innerHTML = `
                    <img src="${item.image}" alt="${item.name}">
                    <div class="crafting-item-name">${item.name}</div>
                    <div class="crafting-item-ingredients">${item.ingredients}</div>
                `;
        itemElement.addEventListener('click', () => craftItem(player, item));
        craftingList.appendChild(itemElement);
    });
    const craftingListList = document.querySelector('.crafting-list');
    if (craftableItems.length === 0) {
        const itemElement = document.createElement('div');
        itemElement.className = 'crafting-disclaimer';
        itemElement.textContent = 'No items available for crafting';
        craftingList.appendChild(itemElement);
        craftingListList.style.display = 'block';
    } else {
        craftingListList.style.display = 'grid';
    }
}

function craftItem(player, item) {
    // This is a placeholder function. In a real implementation,
    // you would handle the crafting logic here.
    console.log(`${player} crafted: ${item.name}`);
    // Add logic to update the player's inventory and the game state
}